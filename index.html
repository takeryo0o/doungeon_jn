
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>è¿·è·¯ã‚²ãƒ¼ãƒ ï¼šãŠå®æ¢ç´¢ç‰ˆ</title>
  <style>
    #maze {
      display: grid;
      gap: 1px;
    }
    .cell {
      width: 32px;
      height: 32px;
      background-color: gray;
      border: 1px solid #ccc;
    }
    .wall.visible {
      background-color: black;
    }
    .path.visible {
      background-color: white;
    }
    .goal.visible {
      background-color: red;
    }
    .start.visible {
      background-color: green;
    }
    .item.visible {
      background-color: purple;
    }
    .item2.visible {
      background-color: gold;
    }
    .player {
      background-color: blue !important;
    }
  </style>
</head>
<body>

<h2>è¿·è·¯ã‚²ãƒ¼ãƒ ï¼šãŠå®æ¢ç´¢ç‰ˆ</h2>
<label>è¦–ç•Œãƒ¬ãƒ™ãƒ«ï¼ˆ1ã€œ5ï¼‰ï¼š</label>
<input type="number" id="visionInput" min="1" max="5" placeholder="ç©ºæ¬„ã§1ã¨åŒã˜">
<br>
<label>ãŠå®æ¢ç´¢ï¼ˆ1:6ãƒã‚¹, 2:8ãƒã‚¹, 3:10ãƒã‚¹ï¼‰:</label>
<input type="number" id="treasureScanInput" min="1" max="3">
<button onclick="scanForTreasures()">æ¢ç´¢ã™ã‚‹</button>
<p id="treasureMessage"></p>
<p id="stage-info"></p>
<p id="treasureCount">å–å¾—ã—ãŸãŠå®ï¼š0å€‹</p>
<div id="maze"></div>

<script>
  let maze = [];
  let playerPos = { x: 0, y: 0 };
  let goalPos = { x: 0, y: 0 };
  let itemPos = null;
  let maxStages = Math.floor(Math.random() * 5) + 1;
  let currentStage = 1;
  let SIZE = 15;
  let fogCleared = false;
  let treasureCollected = 0;

  function getVisionRange() {
    const input = document.getElementById("visionInput").value;
    const num = parseInt(input);
    if (isNaN(num) || num <= 1) return 1;
    if (num <= 3) return 2;
    if (num === 4) return 3;
    if (num >= 5) return 4;
    return 1;
  }

  function updateStageInfo() {
    document.getElementById("stage-info").innerText =
      `ã‚¹ãƒ†ãƒ¼ã‚¸ ${currentStage} / ${maxStages}ï¼ˆ${SIZE}Ã—${SIZE}ï¼‰`;
  }

  function updateTreasureCount() {
    document.getElementById("treasureCount").innerText =
      `å–å¾—ã—ãŸãŠå®ï¼š${treasureCollected}å€‹`;
  }

  function createCell(x, y, isPath) {
    const cell = document.createElement("div");
    cell.classList.add("cell");
    if (isPath) cell.classList.add("path");
    else cell.classList.add("wall");
    cell.dataset.x = x;
    cell.dataset.y = y;
    return cell;
  }

  function updateVisibility() {
    const range = getVisionRange();
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const cell = maze[y][x].el;
        if (fogCleared) {
          cell.classList.add("visible");
        } else {
          const dx = Math.abs(x - playerPos.x);
          const dy = Math.abs(y - playerPos.y);
          if (dx <= range && dy <= range) {
            cell.classList.add("visible");
          }
        }
      }
    }
  }

  function scanForTreasures() {
    const input = document.getElementById("treasureScanInput").value;
    const radius = input === "1" ? 6 : input === "2" ? 8 : input === "3" ? 10 : 0;
    if (radius === 0) {
      document.getElementById("treasureMessage").innerText = "æ­£ã—ã„æ•°å€¤ï¼ˆ1ã€œ3ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
      return;
    }
    let count = 0;
    for (let y = playerPos.y - radius; y <= playerPos.y + radius; y++) {
      for (let x = playerPos.x - radius; x <= playerPos.x + radius; x++) {
        if (
          x >= 0 && x < SIZE &&
          y >= 0 && y < SIZE &&
          maze[y][x].el.classList.contains("item2")
        ) {
          count++;
        }
      }
    }
    document.getElementById("treasureMessage").innerText =
      `å‘¨å›²ã®ãŠå®ã®æ•°ã¯${count}å€‹ã‚ã‚Šãã†ã ãƒ»ãƒ»ãƒ»`;
  }

  function generateMaze() {
    SIZE = Math.floor(Math.random() * 11) + 10;
    fogCleared = false;
    itemPos = null;
    document.getElementById("treasureMessage").innerText = "";

    const container = document.getElementById("maze");
    container.innerHTML = "";
    container.style.gridTemplateColumns = `repeat(${SIZE}, 32px)`;
    container.style.gridTemplateRows = `repeat(${SIZE}, 32px)`;

    maze = [];

    for (let y = 0; y < SIZE; y++) {
      maze[y] = [];
      for (let x = 0; x < SIZE; x++) {
        const isPath = Math.random() < 0.7;
        const cell = createCell(x, y, isPath);
        maze[y][x] = { isPath, el: cell };
        container.appendChild(cell);
      }
    }

    const whiteCells = [];
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        if (maze[y][x].isPath) whiteCells.push({ x, y });
      }
    }

    if (whiteCells.length < 3) {
      generateMaze(); return;
    }

    const start = whiteCells[Math.floor(Math.random() * whiteCells.length)];
    maze[start.y][start.x].el.classList.add("start");
    playerPos = { x: start.x, y: start.y };

    const visited = Array(SIZE).fill(null).map(() => Array(SIZE).fill(false));
    const queue = [{ x: start.x, y: start.y, dist: 0 }];
    let maxDist = -1;
    let goal = null;

    while (queue.length > 0) {
      const { x, y, dist } = queue.shift();
      if (visited[y][x]) continue;
      visited[y][x] = true;
      if (dist > maxDist) {
        maxDist = dist;
        goal = { x, y };
      }
      const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
      for (let [dx, dy] of dirs) {
        const nx = x + dx;
        const ny = y + dy;
        if (
          nx >= 0 && nx < SIZE &&
          ny >= 0 && ny < SIZE &&
          !visited[ny][nx] &&
          maze[ny][nx].isPath
        ) {
          queue.push({ x: nx, y: ny, dist: dist + 1 });
        }
      }
    }

    if (!goal || maxDist <= 0) {
      generateMaze(); return;
    }

    goalPos = { x: goal.x, y: goal.y };
    maze[goal.y][goal.x].el.classList.add("goal");

    if (Math.random() < 0.1) {
      let item;
      do {
        item = whiteCells[Math.floor(Math.random() * whiteCells.length)];
      } while (
        (item.x === goalPos.x && item.y === goalPos.y) ||
        (item.x === start.x && item.y === start.y)
      );
      itemPos = { x: item.x, y: item.y };
      maze[item.y][item.x].el.classList.add("item");
    }

    let treasureCount = 0;
    function tryPlaceTreasures() {
      treasureCount = 0;
      whiteCells.forEach(({ x, y }) => {
        const cell = maze[y][x];
        cell.el.classList.remove("item2");

        if ((x === goalPos.x && y === goalPos.y) || (x === start.x && y === start.y)) return;

        let leftWall = (x - 1 < 0 || !maze[y][x - 1].isPath);
        let rightWall = (x + 1 >= SIZE || !maze[y][x + 1].isPath);
        let prob = 0;

        if (leftWall && rightWall) prob = 0.03;
        else if (leftWall || rightWall) prob = 0.01;
        else prob = 0.0035;

        if (Math.random() < prob) {
          cell.el.classList.add("item2");
          treasureCount++;
        }
      });
    }

    do {
      tryPlaceTreasures();
    } while (treasureCount <= 5);

    maze[playerPos.y][playerPos.x].el.classList.add("player");
    updateVisibility();
    updateStageInfo();
    updateTreasureCount();
  }

  document.addEventListener("keydown", function(e) {
    const activeEl = document.activeElement;
    if (activeEl && (activeEl.id === "visionInput" || activeEl.id === "treasureScanInput")) return;

    const dirs = {
      ArrowUp: [0, -1],
      ArrowDown: [0, 1],
      ArrowLeft: [-1, 0],
      ArrowRight: [1, 0]
    };
    if (!(e.key in dirs)) return;

    const [dx, dy] = dirs[e.key];
    const nx = playerPos.x + dx;
    const ny = playerPos.y + dy;

    if (
      nx >= 0 && nx < SIZE &&
      ny >= 0 && ny < SIZE &&
      maze[ny][nx].isPath
    ) {
      maze[playerPos.y][playerPos.x].el.classList.remove("player");
      playerPos = { x: nx, y: ny };
      maze[ny][nx].el.classList.add("player");

      if (itemPos && nx === itemPos.x && ny === itemPos.y && !fogCleared) {
        fogCleared = true;
        updateVisibility();
        alert("ğŸ§ª éœ§ãŒæ™´ã‚ŒãŸï¼");
      }

      if (maze[ny][nx].el.classList.contains("item2")) {
        maze[ny][nx].el.classList.remove("item2");
        treasureCollected++;
        updateTreasureCount();
      }

      updateVisibility();

      if (nx === goalPos.x && ny === goalPos.y) {
        if (currentStage < maxStages) {
          currentStage++;
          setTimeout(generateMaze, 300);
        } else {
          setTimeout(() => {
            alert("ğŸ‰ å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼");
            treasureCollected = 0;
            updateTreasureCount();
            currentStage = 1;
            generateMaze();
          }, 200);
        }
      }
    }
  });

  generateMaze();
</script>

</body>
</html>
